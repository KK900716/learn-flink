1. 继承 Thread
    ```
    /**
    * 1.创建一个继承于Thread类的子类
    * 2.重写Thread雷的run方法
    * 3.创建Thread类的子类的对象
    * 4.通过此对象调用start()
    */
    public class testalgorithm {
        public static void main(String[] args) {
            MyThread1 myThread1 = new MyThread1();
            MyThread2 myThread2 = new MyThread2();
            myThread1.start();
            myThread2.start();
        }
    }
    class MyThread1 extends Thread{
        @Override
        public void run() {
            for (int i = 0; i < 100; i++) {
                if (i%2==0){
                    System.out.println(i);
                }
            }
        }
    }
    class MyThread2 extends Thread{
        @Override
        public void run() {
            for (int i = 0; i < 100; i++) {
                if (i%3==0){
                    System.out.println(i);
                }
            }
        }
    }
    ```
    1. Thread.currentThread()返回当前线程（静态方法）
        1. Thread.currentThread().getName()获取当前线程名
        2. setName()设置线程名
    2. Thread.sleep()线程休眠
    3. 可以制造一个构造器将线程名传入父类
    ```
    public Thread(String name){super(name)}
    ```
    4. yield()释放当前线程（cpu释放当前线程执行权）
    5. join()在线程a调用其他线程的join方法，此时线程a进入阻塞直到其他线程执行完后才结束阻塞状态
    6. stop()结束当前线程（已过时）
    7. isAlive()判断当前线程是否存活
    8. 线程优先级
        1. MAX_PRIORITY 10
        2. MIN_PRIORITY 1
        3. NORM_PRIORITY 5
        4. getPriority 获取优先级
        5. setPriority 设置优先级
        6. 高优先级概率上枪战低优先级的cpu占有权，并不意味着只有高优先级的线程执行完以后，才执行低优先级线程
2. 实现 Runnable接口
    ```
    /**
    * 1.创建一个继承于Thread类的子类
    * 2.实现run方法
    * 3.创建实现类对象
    * 4.将此对象作为阐述传递到Thread类的构造器中，创建Thread类的对象
    * 5.调用start方法
    */
    public class test {
        public static void main(String[] args) throws InterruptedException {
            Thread myThread = new Thread(new MyThread());
            myThread.start();
        }
    }
    class MyThread implements Runnable{
        @Override
        public void run() {
            for (int i = 0; i < 100; i++) {
                if (i%2==0){
                    System.out.println(i);
                }
            }
        }
    }
    ```
3. 对比
    1. 开发中，优先选择接口方式
    2. 实现的方式没有类的单继承性的局限性
    3. 实现的方式更时候来处理多个线程有共享数据的情况
4. java中的线程分类
    1. 一种是守护线程，一种是用户线程，通过在start方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程
    2. java垃圾回收就是一个典型的守护线程
    3. jvm中都是守护线程则jvm将退出
5. 线程的生命周期
    1. State
        1. NEW
        2. RUNNABLE
        3. BLOCKED
        4. WAITING
        5. TIMED_WAITING
        6. TERMINATED
    2. 状态
        1. 新建 阻塞
        2. 就绪 调用start进入就绪队列
        3. 运行
        4. 阻塞
            1. 运行到阻塞 调用sleep、join、等待同步锁wait、suspend挂起（过时，可能会导致死锁，搭配resume使用）
            2. 阻塞到就绪 sleep时间结束、join结束、获取同步锁、notify/notifyAll、resume
        5. 死亡 执行完毕或调用stop
6. 解决线程安全问题
    1. 同步代码块
        1. synchronized(同步监视器){
            需要被同步的代码
        }
        2. 同步监视器，俗称锁，任何一个类的对象都可以充当锁
        3. 要求多个线程必须公用同一把锁
        4. 缺点 在同步代码块中是单线程执行，效率低
    2. 