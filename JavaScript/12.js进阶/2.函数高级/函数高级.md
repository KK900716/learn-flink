1. 关于分号问题
2. 原型与原型链
    1. prototype属性
        1. 每个函数都有一个prototype属性，他默认指向一个Object空对象，即原型对象
            1. 空对象指没有用户的属性
        2. 原型对象中有一个属性constructor，他指向函数对象
    2. 给原型对象添加属性（一般都是方法）
        作用：函数的所有实例对象自动拥有原型中的属性（方法）
    3. 显式原型和隐式原型
        1. 每个函数都有prototype，即显式原型（属性）
        2. 每个势力对象都有一个__proto__，可称为隐式原型（属性）
        3. 对象的隐式原型的值为其对应构造函数的显式原型的值
    4. 程序员能直接操作显式原型，但不能直接操作隐式原型（ES6之前）
    5. 原型链
        1. hasOwnProperty()是否包含我们定义的某个属性
        2. toString()是原型链尽头的一个方法
        3. 如果要使用某个属性，会沿着原型链一直找到Object的原型对象，Object的__proto__属性是null，故原型链的尽头就是该对象
        4. 原型链的别名是隐式原型链，因为在找原型链时是沿着隐式原型找的，找不到该属性时返回undefined
        5. 由于函数是Function的实例对象，所以所有的函数还拥有隐式原型属性__proto__指向Function的显式原型属性
        6. 由于Function是系统定义的函数对象，所以该对象也拥有一个隐式原型属性__proto__指向自己的显式原型属性prototype，也仅有该对象的显式和隐式原型属性指向相同，即如果定义该函数时，产生的对象其实就是new其自身
        7. 这样我们可以得到所有函数的隐式原型属性__proto__都指向相同的对象，即Function的显式原型属性prototype指向的对象，其自身也不例外
        8. 那么Object()函数的隐式原型属性也不例外指向7那个空对象
        9. 这里需要注意，函数的显式原型对象指向的那个对象是空的Object实例对象，Object()例外，因为所有的实例对象都拥有一个隐式原型属性指向构造他的那个函数的显示原型属性即Object的显式原型属性也是原型链的尽头
    6. 给一个对象添加属性时，属性在对象身上，方法在原型身上
    7. instanceof判断的方法就是查看构造函数对象的显式原型属性指向的对象是否在要判断对象的的原型链上
3. 执行上下文与执行上下文栈
    1. 变量提升与函数提升
        1. 通过var定义的变量在定义语句之前就可以访问到，即变量声明提升
        2. 通过function声明的函数，在之前就可以直接调用，即函数声明提升
    2. 执行上下文
        1. 全局执行上下文
            1. 在执行全局代码前将window确定为全局执行上下文
            2. 对全局数据进行预处理
                1. var定义的全局变量==>undefined，添加为window的属性
                2. function声明的全局函数==>赋值（fun），添加为window的方法
                3. this==>赋值（window）
            3. 开始执行全局代码
        2. 函数执行上下文
            1. 在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟）
            2. 对局部数据进行预处理
                1. 形参变量==>赋值（实参）==>添加为执行上下文的属性
                2. arguments==>赋值（实参列表），添加为执行上下文的属性
                3. var定义的局部变量==>赋值（fun），添加执行上下文的方法
                4. this==>赋值（调用函数的对象）
            3. 开始执行函数体代码
            4. arguments是一个伪数组，存储传递的参数
    3. 执行上下文栈
        1. 在全局代码执行前，JS引擎就会创建一个栈来存储管理所有的执行上下文对象
        2. 在全局执行上下文（window）确定后，将其添加到栈中（压栈）
        3. 在函数执行上下文创建后，将其添加到栈中（压栈）
        4. 在当前函数执行完后，将栈顶的对象移除（出栈）
        5. 当所有的代码执行完后，栈中只剩下window
4. 作用域与作用域链
    1. 作用 隔离变量，不同作用于下不同名变量不会有冲突
    2. 作用域与执行上下文的区别
        1. 区别1
            1. 全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是再函数调用时
            2. 全局执行上下文环境实在全局作用域确定之后，js代码马上执行之前创建
            3. 函数执行上下文是在调用函数时，函数体代码执行之前创建
        2. 区别2
            1. 作用域是静态的，只要函数定义好了就一直存在，且不会再变化
            2. 执行上下文是动态的额，调用函数时创建，函数调用结束时就会自动释放
        3. 联系
            1. 上下文环境（对象）是从属于所在的作用域
            2. 全局上下文环境==>全局作用域
            3. 函数上下文环境==>对应的函数使用域
5. 闭包
    1. 如何产生闭包
        当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包
    2. 闭包是什么
        1. 闭包是嵌套的内部函数
        2. 包含被引用变量（函数）的对象
        3. 闭包
        4. 闭包存在于嵌套的内部函数中
    3. 产生闭包的条件
        1. 函数潜逃
        2. 内部函数引用了外部函数的数据（变量/函数）
    4. 执行函数定义就会产生闭包
    5. 常见的闭包
        1. 将函数作为另外一个函数的返回值
        2. 将函数作为实参传递给另一个函数调用
    6. 闭包的作用
        1. 使用函数内部的变量在函数执行完之后，仍然存活在内存中（延长了局部变量的生命周期）
        2. 让函数外部可以操作（读写）到函数内部的数据（变量/函数）
        3. 函数执行完后，函数内部生命的局部变量若存在闭包可能会使局部变量继续存活
        4. 函数外部可以通过闭包操作函数内部的局部变量
    7. 函数闭包的缺点
        1. 函数执行完后，函数内部的局部变量没有释放，占用内存时间变长
        2. 容易造成内存泄露