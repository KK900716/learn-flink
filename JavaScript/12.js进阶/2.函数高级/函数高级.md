1. 关于分号问题
2. 原型与原型链
    1. prototype属性
        1. 每个函数都有一个prototype属性，他默认指向一个Object空对象，即原型对象
            1. 空对象指没有用户的属性
        2. 原型对象中有一个属性constructor，他指向函数对象
    2. 给原型对象添加属性（一般都是方法）
        作用：函数的所有实例对象自动拥有原型中的属性（方法）
    3. 显式原型和隐式原型
        1. 每个函数都有prototype，即显式原型（属性）
        2. 每个势力对象都有一个__proto__，可称为隐式原型（属性）
        3. 对象的隐式原型的值为其对应构造函数的显式原型的值
    4. 程序员能直接操作显式原型，但不能直接操作隐式原型（ES6之前）
    5. 原型链
        1. hasOwnProperty()是否包含我们定义的某个属性
        2. toString()
        3. 如果要使用某个属性，会沿着原型链一直找到Object的原型对象，Object的__proto__属性是null，故原型链的尽头就是该对象
        4. 原型链的别名是隐式原型链，因为在找原型链时是沿着隐式原型找的，找不到该属性时返回undefined
        5. 由于函数是Function的实例对象，所以所有的函数还拥有隐式原型属性__proto__指向Function的显式原型属性
        6. 由于Function是系统定义的函数对象，所以该对象也拥有一个隐式原型属性__proto__指向自己的显式原型属性prototype，也仅有该对象的显式和隐式原型属性指向相同，即如果定义该函数时，产生的对象其实就是new其自身
        7. 这样我们可以得到所有函数的隐式原型属性__proto__都指向相同的对象，即Function的显式原型属性prototype指向的对象，其自身也不例外
        8. 那么Object()函数的隐式原型属性也不例外指向7那个空对象
        9. 这里需要注意，函数的显式原型对象指向的那个对象是空的Object实例对象，Object()例外，因为所有的实例对象都拥有一个隐式原型属性指向构造他的那个函数的显示原型属性即Object的显式原型属性也是原型链的尽头
3. 执行上下文与执行上下文栈
4. 作用域与作用域链
5. 闭包